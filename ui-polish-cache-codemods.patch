From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ChatGPT Design Refactor <tileify@worldclass.dev>
Date: Sat, 4 Oct 2025 15:40:00 +0000
Subject: [PATCH] chore(ui+dx): add Tile system + typography headings, cached query hook, and codemods for visual polish and dead-code discovery

---
 src/components/ui/Tile.tsx                  | 66 +++++++++++++++++++++++++++++
 src/components/ui/SectionHeading.tsx        | 24 +++++++++++
 src/lib/cache/lru.ts                        | 79 ++++++++++++++++++++++++++++++
 src/lib/cache/local.ts                      | 41 ++++++++++++++++
 src/hooks/useCachedQuery.ts                 | 87 +++++++++++++++++++++++++++++++++
 scripts/wrap-tiles.js                       | 219 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 scripts/find-dead-code.js                   | 155 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 README_TILEIFY.md                           |  64 ++++++++++++++++++++++
 8 files changed, 735 insertions(+)
 create mode 100644 src/components/ui/Tile.tsx
 create mode 100644 src/components/ui/SectionHeading.tsx
 create mode 100644 src/lib/cache/lru.ts
 create mode 100644 src/lib/cache/local.ts
 create mode 100644 src/hooks/useCachedQuery.ts
 create mode 100755 scripts/wrap-tiles.js
 create mode 100755 scripts/find-dead-code.js
 create mode 100644 README_TILEIFY.md

diff --git a/src/components/ui/Tile.tsx b/src/components/ui/Tile.tsx
new file mode 100644
index 0000000..b1c0a3e
--- /dev/null
+++ b/src/components/ui/Tile.tsx
@@
+import React from "react";
+
+type TileProps = React.PropsWithChildren<{
+  title?: string;
+  subtitle?: string;
+  footer?: React.ReactNode;
+  className?: string;
+}>;
+
+/**
+ * Premium Card / Tile component with consistent spacing & polish.
+ * - rounded-2xl, soft shadow, subtle gradient background
+ * - title/subtitle header and optional footer
+ * - drop-in replacement to wrap existing content without logic changes
+ */
+export default function Tile({ title, subtitle, footer, className = "", children }: TileProps) {
+  return (
+    <div
+      className={[
+        "rounded-2xl p-5 border",
+        "bg-[radial-gradient(1200px_400px_at_0%_0%,rgba(0,0,0,0.03),transparent)]",
+        "shadow-sm hover:shadow transition-shadow",
+        className,
+      ].join(" ")}
+    >
+      {(title || subtitle) && (
+        <div className="mb-3">
+          {title && <div className="text-lg font-semibold tracking-tight">{title}</div>}
+          {subtitle && <div className="text-xs opacity-70">{subtitle}</div>}
+        </div>
+      )}
+      <div className="space-y-3">{children}</div>
+      {footer && <div className="mt-4 pt-3 border-t">{footer}</div>}
+    </div>
+  );
+}
diff --git a/src/components/ui/SectionHeading.tsx b/src/components/ui/SectionHeading.tsx
new file mode 100644
index 0000000..a2a2a2a
--- /dev/null
+++ b/src/components/ui/SectionHeading.tsx
@@
+import React from "react";
+
+export default function SectionHeading({ children }: { children: React.ReactNode }) {
+  return (
+    <h2 className="text-xl font-semibold tracking-tight flex items-center gap-2">
+      <span className="inline-block w-1.5 h-1.5 rounded-full bg-black/70" />
+      {children}
+    </h2>
+  );
+}
diff --git a/src/lib/cache/lru.ts b/src/lib/cache/lru.ts
new file mode 100644
index 0000000..d1d1d1d
--- /dev/null
+++ b/src/lib/cache/lru.ts
@@
+type Entry<V> = { value: V; expiresAt: number };
+
+export default class LRUCache<K, V> {
+  private max: number;
+  private store = new Map<K, Entry<V>>();
+
+  constructor(max = 200) { this.max = max; }
+
+  get(key: K): V | undefined {
+    const e = this.store.get(key);
+    if (!e) return undefined;
+    if (e.expiresAt < Date.now()) { this.store.delete(key); return undefined; }
+    // refresh LRU position
+    this.store.delete(key);
+    this.store.set(key, e);
+    return e.value;
+  }
+
+  set(key: K, value: V, ttlMs = 60_000) {
+    const e: Entry<V> = { value, expiresAt: Date.now() + ttlMs };
+    if (this.store.has(key)) this.store.delete(key);
+    this.store.set(key, e);
+    if (this.store.size > this.max) {
+      const first = this.store.keys().next().value;
+      this.store.delete(first);
+    }
+  }
+
+  has(key: K) { return this.get(key) !== undefined; }
+  clear() { this.store.clear(); }
+}
diff --git a/src/lib/cache/local.ts b/src/lib/cache/local.ts
new file mode 100644
index 0000000..d2d2d2d
--- /dev/null
+++ b/src/lib/cache/local.ts
@@
+export function setLocal<T>(key: string, value: T, ttlMs = 60_000) {
+  try {
+    const payload = { v: value, e: Date.now() + ttlMs };
+    localStorage.setItem(key, JSON.stringify(payload));
+  } catch {}
+}
+
+export function getLocal<T>(key: string): T | null {
+  try {
+    const raw = localStorage.getItem(key);
+    if (!raw) return null;
+    const { v, e } = JSON.parse(raw);
+    if (Date.now() > e) { localStorage.removeItem(key); return null; }
+    return v as T;
+  } catch { return null; }
+}
diff --git a/src/hooks/useCachedQuery.ts b/src/hooks/useCachedQuery.ts
new file mode 100644
index 0000000..d3d3d3d
--- /dev/null
+++ b/src/hooks/useCachedQuery.ts
@@
+import { useEffect, useState } from "react";
+import LRUCache from "@/lib/cache/lru";
+import { getLocal, setLocal } from "@/lib/cache/local";
+
+// App-wide in-memory cache (per tab)
+const mem = new LRUCache<string, any>(300);
+
+/**
+ * Cached query hook for client-side loaders:
+ * - memory cache (fast) + localStorage TTL (survives reloads)
+ * - configurable TTL
+ * - dedupes concurrent calls by key (simple in-memory guard)
+ */
+const inflight = new Map<string, Promise<any>>();
+
+export default function useCachedQuery<T>(key: string, loader: () => Promise<T>, ttlMs = 60_000) {
+  const [data, setData] = useState<T | null>(() => {
+    const m = mem.get(key);
+    if (m !== undefined) return m as T;
+    const l = getLocal<T>(key);
+    return l;
+  });
+  const [loading, setLoading] = useState(!data);
+  const [error, setError] = useState<Error | null>(null);
+
+  useEffect(() => {
+    let mounted = true;
+    async function run() {
+      try {
+        setLoading(true);
+        const pending = inflight.get(key) || loader();
+        inflight.set(key, pending);
+        const fresh = await pending;
+        inflight.delete(key);
+        if (!mounted) return;
+        setData(fresh);
+        mem.set(key, fresh, ttlMs);
+        setLocal(key, fresh, ttlMs);
+      } catch (e: any) {
+        if (!mounted) return;
+        setError(e);
+      } finally {
+        if (mounted) setLoading(false);
+      }
+    }
+    run();
+    return () => { mounted = false; };
+  // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [key]);
+
+  return {
+    data, loading, error,
+    refresh: async () => {
+      const fresh = await loader();
+      setData(fresh);
+      mem.set(key, fresh, ttlMs);
+      setLocal(key, fresh, ttlMs);
+      return fresh;
+    }
+  };
+}
diff --git a/scripts/wrap-tiles.js b/scripts/wrap-tiles.js
new file mode 100755
index 0000000..aabbccd
--- /dev/null
+++ b/scripts/wrap-tiles.js
@@
+#!/usr/bin/env node
+/**
+ * Codemod: Wraps dashboard cards with <Tile /> for consistent visuals
+ * WITHOUT changing their logic/content.
+ *
+ * - Scans src/components/tiles and src/components/hub
+ * - Adds:   import Tile from "@/components/ui/Tile";
+ * - Wraps top-level `return (` JSX with <Tile title="ComponentName"> … </Tile>
+ * - Writes .bak backups
+ *
+ * Idempotent: safe to run multiple times.
+ */
+
+const fs = require("fs");
+const path = require("path");
+
+const ROOT = process.cwd();
+const SRC = path.join(ROOT, "src");
+
+function walk(dir, files = []) {
+  if (!fs.existsSync(dir)) return files;
+  for (const entry of fs.readdirSync(dir)) {
+    const full = path.join(dir, entry);
+    const stat = fs.statSync(full);
+    if (stat.isDirectory()) walk(full, files);
+    else files.push(full);
+  }
+  return files;
+}
+
+function guessTitleFromName(filename) {
+  const base = path.basename(filename).replace(/\.(tsx|jsx|ts|js)$/i, "");
+  return base.replace(/([a-z])([A-Z])/g, "$1 $2"); // PascalCase → "Pascal Case"
+}
+
+function ensureTileImport(src) {
+  if (src.includes('from "@/components/ui/Tile"')) return src;
+  const lines = src.split(/\r?\n/);
+  let insertAt = 0;
+  for (let i = 0; i < lines.length; i++) {
+    if (!lines[i].startsWith("import ")) { insertAt = i; break; }
+  }
+  lines.splice(insertAt, 0, 'import Tile from "@/components/ui/Tile";');
+  return lines.join("\n");
+}
+
+function wrapReturnWithTile(src, title) {
+  if (src.includes("<Tile") && src.includes("</Tile>")) return src; // already wrapped
+  const idx = src.indexOf("return (");
+  if (idx === -1) return src;
+  const before = src.slice(0, idx);
+  const after = src.slice(idx + "return (".length);
+  const endIdx = after.lastIndexOf(");");
+  if (endIdx === -1) return src;
+  const inside = after.slice(0, endIdx);
+  const tail = after.slice(endIdx);
+  const wrapped = `return (<Tile title="${title}">\n${inside}\n</Tile>` + tail;
+  return before + wrapped;
+}
+
+function processFile(file) {
+  const rel = path.relative(ROOT, file);
+  if (!/\.(tsx|jsx)$/.test(file)) return { rel, changed: false, reason: "not tsx/jsx" };
+  let src = fs.readFileSync(file, "utf8");
+  const original = src;
+  if (/ViralityScoreTile\.tsx$/.test(file)) return { rel, changed: false, reason: "skip virality (maybe already wrapped)" };
+
+  const title = guessTitleFromName(file);
+  src = ensureTileImport(src);
+  src = wrapReturnWithTile(src, title);
+
+  if (src !== original) {
+    fs.writeFileSync(file + ".bak", original, "utf8");
+    fs.writeFileSync(file, src, "utf8");
+    return { rel, changed: true };
+  }
+  return { rel, changed: false, reason: "no-op" };
+}
+
+const targets = [
+  path.join(SRC, "components", "tiles"),
+  path.join(SRC, "components", "hub"),
+];
+
+const files = targets.flatMap(d => walk(d)).filter(f => /\.(tsx|jsx)$/.test(f));
+const result = files.map(processFile);
+
+const summary = {
+  scanned: files.length,
+  changed: result.filter(r => r.changed).length,
+  details: result,
+};
+
+console.log(JSON.stringify(summary, null, 2));
+console.log("\n✅ Done. Backups saved as *.bak next to changed files.");
+console.log("Tip: run git diff to review, then remove .bak files after merge.");
+
diff --git a/scripts/find-dead-code.js b/scripts/find-dead-code.js
new file mode 100755
index 0000000..ddccbb1
--- /dev/null
+++ b/scripts/find-dead-code.js
@@
+#!/usr/bin/env node
+/**
+ * Dead-code discovery (non-destructive).
+ * Builds a simple import graph from src/**/*.ts(x) and reports files that
+ * have no importers and are not entrypoints.
+ *
+ * Usage:
+ *   node scripts/find-dead-code.js
+ */
+
+const fs = require("fs");
+const path = require("path");
+
+const ROOT = process.cwd();
+const SRC = path.join(ROOT, "src");
+
+function walk(dir, files = []) {
+  if (!fs.existsSync(dir)) return files;
+  for (const entry of fs.readdirSync(dir)) {
+    const full = path.join(dir, entry);
+    const stat = fs.statSync(full);
+    if (stat.isDirectory()) walk(full, files);
+    else files.push(full);
+  }
+  return files;
+}
+
+const all = walk(SRC).filter(f => /\.(tsx|ts|jsx|js)$/.test(f));
+const imports = new Map(); // file -> set(imported file)
+const importers = new Map(); // file -> set(files that import it)
+
+function add(map, k, v) {
+  if (!map.has(k)) map.set(k, new Set());
+  map.get(k).add(v);
+}
+
+function resolveImport(from, spec) {
+  if (!spec.startsWith(".") && !spec.startsWith("@/")) return null; // ignore packages
+  const fromDir = path.dirname(from);
+  let target = spec.startsWith("@/") ? path.join(SRC, spec.replace(/^@\//, "")) : path.join(fromDir, spec);
+  const candidates = [
+    target, target + ".ts", target + ".tsx", target + ".js", target + ".jsx",
+    path.join(target, "index.ts"), path.join(target, "index.tsx"),
+  ];
+  for (const c of candidates) if (fs.existsSync(c)) return c;
+  return null;
+}
+
+for (const file of all) {
+  const text = fs.readFileSync(file, "utf8");
+  const re = /import\s+[^'"]+from\s+['"]([^'"]+)['"]/g;
+  let m;
+  while ((m = re.exec(text))) {
+    const spec = m[1];
+    const target = resolveImport(file, spec);
+    if (target) {
+      add(imports, file, target);
+      add(importers, target, file);
+    }
+  }
+}
+
+// Entrypoints (common): pages/*, app/*, src/main.tsx, src/index.tsx, src/App.tsx
+const entryCandidates = [
+  path.join(ROOT, "pages"), path.join(ROOT, "app"),
+  path.join(SRC, "main.tsx"), path.join(SRC, "index.tsx"),
+  path.join(SRC, "App.tsx"),
+];
+const entries = new Set(all.filter(f => entryCandidates.some(p => f.startsWith(p))));
+
+const dead = all.filter(f => !entries.has(f) && !(importers.get(f) && importers.get(f).size));
+
+console.log(JSON.stringify({
+  total: all.length,
+  entries: entries.size,
+  dead_count: dead.length,
+  dead_samples: dead.slice(0, 50),
+}, null, 2));
+
+console.log("\nNote: This is a heuristic. Review before deleting anything.");
+
diff --git a/README_TILEIFY.md b/README_TILEIFY.md
new file mode 100644
index 0000000..ddeeff0
--- /dev/null
+++ b/README_TILEIFY.md
@@
+# Tileify — polish cards & cache reads (without logic changes)
+
+This patch adds:
+
+- **`<Tile />`** and **`<SectionHeading />`** for a premium, consistent look
+- **`useCachedQuery`** hook + mini LRU/localStorage cache to reduce repeated reads
+- **Codemod** `scripts/wrap-tiles.js` to wrap existing cards automatically
+- **Dead-code finder** `scripts/find-dead-code.js` to report files with no importers
+
+## Wrap tiles (visual polish)
+```bash
+node scripts/wrap-tiles.js
+git add -A
+git commit -m "chore(ui): wrap tiles with Tile (visual polish)"
+```
+
+## Use the cache hook (optional, per-component)
+```ts
+import useCachedQuery from "@/hooks/useCachedQuery";
+
+const { data, loading } = useCachedQuery("referrals:count", async () => {
+  const res = await fetch("/api/referrals-count");
+  const json = await res.json();
+  return json.count ?? 0;
+}, 120_000);
+```
+
+## Find likely dead code (safe)
+```bash
+node scripts/find-dead-code.js
+```
+Review the report and remove only what you’re comfortable with.
+
+> All additions are **backwards-compatible** and **idempotent**. No functionality was changed.
+
--
2.46.0
